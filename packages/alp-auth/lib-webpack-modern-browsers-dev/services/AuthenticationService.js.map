{"version":3,"sources":["../../src/services/AuthenticationService.js"],"names":[],"mappings":"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","file":"AuthenticationService.js","sourcesContent":["/* eslint camelcase: \"off\" */\nimport EventEmitter from 'events';\nimport promiseCallback from 'promise-callback-factory';\nimport Logger from 'nightingale-logger';\nimport UserAccountsService from './user/UserAccountsService';\nimport { randomHex } from '../utils/generators';\n\nconst logger = new Logger('alp-auth.services.authentication');\n\ntype GenerateAuthUrlOptions = {\n    redirectUri?: string;\n    scope?: string;\n    state?: string;\n    grantType?: string;\n    accessType?: string;\n    prompt?: string;\n    loginHint?: string;\n    includeGrantedScopes?: boolean;\n}\n\ntype GetTokensOptions = {\n    code: string;\n    redirectUri: string;\n}\n\nexport default class AuthenticationService extends EventEmitter {\n    config: Object;\n    strategies: Object;\n    userAccountsService: UserAccountsService;\n\n\n    constructor(config, strategies: Object, userAccountsService: UserAccountsService) {\n        super();\n        this.config = config;\n        this.strategies = strategies;\n        this.userAccountsService = userAccountsService;\n    }\n\n    /**\n     *\n     * @param {string} strategy\n     * @param {Object} options\n     * @param {string} [options.redirectUri]\n     * @param {string} [options.scope] Space-delimited set of permissions that the application requests.\n     * @param {string} [options.state] Any string that might be useful to your application upon receipt of the response\n     * @param {string} [options.grantType]\n     * @param {string} [options.accessType = 'online'] online or offline\n     * @param {string} [options.prompt] Space-delimited, case-sensitive list of prompts to present the user. values: none, consent, select_account\n     * @param {string} [options.loginHint] email address or sub identifier\n     * @param {boolean} [options.includeGrantedScopes] If this is provided with the value true, and the authorization request is granted, the authorization will include any previous authorizations granted to this user/application combination for other scopes\n     * @returns {string}\n     */\n    generateAuthUrl(strategy: string, options: GenerateAuthUrlOptions = {}) {\n        logger.debug('generateAuthUrl', { strategy, options });\n        const strategyInstance = this.strategies[strategy];\n        switch (strategyInstance.type) {\n            case 'oauth2':\n                return strategyInstance.oauth2.authCode.authorizeURL({\n                    redirect_uri: options.redirectUri,\n                    scope: options.scope,\n                    state: options.state,\n                    grant_type: options.grantType,\n                    access_type: options.accessType,\n                    login_hint: options.loginHint,\n                    include_granted_scopes: options.includeGrantedScopes,\n                });\n\n        }\n    }\n\n\n    getTokens(strategy: string, options: GetTokensOptions = {}) {\n        logger.debug('getTokens', { strategy, options });\n        const strategyInstance = this.strategies[strategy];\n        switch (strategyInstance.type) {\n            case 'oauth2':\n                return promiseCallback((done) => {\n                    strategyInstance.oauth2.authCode.getToken({\n                        code: options.code,\n                        redirect_uri: options.redirectUri,\n                    }, done);\n                }).then(result => (\n                    result && {\n                        accessToken: result.access_token,\n                        refreshToken: result.refresh_token,\n                        tokenType: result.token_type,\n                        expiresIn: result.expires_in,\n                        expireDate: (() => {\n                            const d = new Date();\n                            d.setTime(d.getTime() + (result.expires_in * 1000));\n                            return d;\n                        })(),\n                        idToken: result.id_token,\n                    }\n                    // return strategyInstance.accessToken.create(result);\n                ));\n        }\n    }\n\n    refreshToken(strategy: string, tokens) {\n        logger.debug('refreshToken', { strategy });\n        if (!tokens.refreshToken) {\n            throw new Error('Missing refresh token');\n        }\n        const strategyInstance = this.strategies[strategy];\n        switch (strategyInstance.type) {\n            case 'oauth2': {\n                const token = strategyInstance.oauth2.accessToken.create({\n                    refresh_token: tokens.refreshToken,\n                });\n                return promiseCallback(done => token.refresh(done))\n                    .then((result) => {\n                        const tokens = result.token;\n                        return result && {\n                            accessToken: tokens.access_token,\n                            tokenType: tokens.token_type,\n                            expiresIn: tokens.expires_in,\n                            expireDate: (() => {\n                                const d = new Date();\n                                d.setTime(d.getTime() + (tokens.expires_in * 1000));\n                                return d;\n                            })(),\n                            idToken: tokens.id_token,\n                        };\n                    });\n            }\n        }\n    }\n\n    redirectUri(ctx, strategy: string) {\n        const host = `http${this.config.get('allowHttps') ? 's' : ''}://${ctx.request.host}`;\n        return `${host}${ctx.urlGenerator('loginResponse', { strategy })}`;\n    }\n\n    /**\n     *\n     * @param {Koa.Context} ctx\n     * @param {string} strategy\n     * @param {string} [refreshToken]\n     * @param {string} [scopeKey='login']\n     * @param user\n     * @param accountId\n     * @returns {*}\n     */\n    async redirectAuthUrl(\n        ctx:Object,\n        strategy:string,\n        refreshToken:?string,\n        scopeKey: ?string,\n        user,\n        accountId\n    ) {\n        logger.debug('redirectAuthUrl', { strategy, scopeKey, refreshToken });\n        const state = await randomHex(8);\n        const isLoginAccess = !scopeKey || scopeKey === 'login';\n        const scope = this.userAccountsService.getScope(strategy, scopeKey || 'login', user, accountId);\n\n        ctx.cookies.set(`auth_${strategy}_${state}`, JSON.stringify({\n            scopeKey: scopeKey,\n            scope: scope,\n            isLoginAccess: isLoginAccess,\n        }), {\n            maxAge: 10 * 60 * 1000,\n            httpOnly: true,\n            secure: this.config.get('allowHttps'),\n        });\n        const redirectUri = this.generateAuthUrl(strategy, {\n            redirectUri: this.redirectUri(ctx, strategy),\n            scope: scope,\n            state: state,\n            accessType: refreshToken ? 'offline' : 'online',\n        });\n\n        return await ctx.redirect(redirectUri);\n    }\n\n    /**\n     * @param {Koa.Context} ctx\n     * @param {string} strategy\n     * @param {boolean} isConnected\n     * @returns {*}\n     */\n    async accessResponse(ctx, strategy: string, isConnected: ?boolean) {\n        if (ctx.query.error) {\n            const error = new Error(ctx.query.error);\n            error.status = 403;\n            error.expose = true;\n            throw error;\n        }\n\n        const code = ctx.query.code;\n        const state = ctx.query.state;\n        const cookieName = `auth_${strategy}_${state}`;\n        let cookie = ctx.cookies.get(cookieName);\n        ctx.cookies.set(cookieName, '', { expires: new Date(1) });\n        if (!cookie) {\n            throw new Error('No cookie for this state');\n        }\n\n        cookie = JSON.parse(cookie);\n        if (!cookie || !cookie.scope) {\n            throw new Error('Unexpected cookie value');\n        }\n\n        if (!cookie.isLoginAccess) {\n            if (!isConnected) {\n                throw new Error('You are not connected');\n            }\n        }\n\n        const tokens = await this.getTokens(strategy, {\n            code: code,\n            redirectUri: this.redirectUri(ctx, strategy),\n        });\n\n        if (cookie.isLoginAccess) {\n            const user = await this.userAccountsService.findOrCreateFromGoogle(\n                strategy,\n                tokens,\n                cookie.scope,\n                cookie.scopeKey\n            );\n            return user;\n        }\n\n        ctx.cookies.set(cookieName, '', { expires: new Date(1) });\n        const connectedUser = ctx.state.connected;\n        await this.userAccountsService.update(connectedUser, strategy, tokens, cookie.scope, cookie.scopeKey);\n        return connectedUser;\n    }\n\n    refreshAccountTokens(user, account) {\n        if (account.tokenExpireDate && account.tokenExpireDate.getTime() > Date.now()) {\n            return Promise.resolve(false);\n        }\n        return this.refreshToken(account.provider, {\n            accessToken: account.accessToken,\n            refreshToken: account.refreshToken,\n        }).then((tokens) => {\n            if (!tokens) {\n                // serviceGoogle.updateFields({ accessToken:null, refreshToken:null, status: M.Service.OUTDATED });\n                return false;\n            }\n            account.accessToken = tokens.accessToken;\n            account.tokenExpireDate = tokens.expireDate;\n            return this.userAccountsService.updateAccount(user, account).then(() => true);\n        });\n    }\n}\n"]}