{"version":3,"sources":["../../src/services/AuthenticationService.js"],"names":["EventEmitter","promiseCallback","Logger","UserAccountsService","randomHex","logger","GenerateAuthUrlOptions","redirectUri","scope","state","grantType","accessType","prompt","loginHint","includeGrantedScopes","GetTokensOptions","code","AuthenticationService","config","strategies","userAccountsService","strategy","options","debug","strategyInstance","type","oauth2","authorizationCode","authorizeURL","redirect_uri","grant_type","access_type","login_hint","include_granted_scopes","done","getToken","then","result","accessToken","access_token","refreshToken","refresh_token","tokenType","token_type","expiresIn","expires_in","expireDate","d","Date","setTime","getTime","idToken","id_token","tokens","Error","token","create","refresh","ctx","host","get","request","urlGenerator","scopeKey","user","accountId","getScope","cookies","set","JSON","stringify","isLoginAccess","maxAge","httpOnly","secure","generateAuthUrl","redirect","isConnected","query","error","status","expose","cookieName","cookie","expires","parse","getTokens","findOrCreateFromGoogle","connectedUser","connected","update","account","tokenExpireDate","now","Promise","resolve","provider","updateAccount"],"mappings":"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","file":"AuthenticationService.js","sourcesContent":["/* eslint camelcase: 'off', max-lines: 'off' */\nimport EventEmitter from 'events';\nimport promiseCallback from 'promise-callback-factory';\nimport Logger from 'nightingale-logger';\nimport UserAccountsService from './user/UserAccountsService';\nimport { randomHex } from '../utils/generators';\n\nconst logger = new Logger('alp:auth:authentication');\n\ntype GenerateAuthUrlOptions = {\n  redirectUri?: string,\n  scope?: string,\n  state?: string,\n  grantType?: string,\n  accessType?: string,\n  prompt?: string,\n  loginHint?: string,\n  includeGrantedScopes?: boolean,\n}\n\ntype GetTokensOptions = {\n  code: string,\n  redirectUri: string,\n}\n\nexport default class AuthenticationService extends EventEmitter {\n  config: Object;\n  strategies: Object;\n  userAccountsService: UserAccountsService;\n\n  constructor(config, strategies: Object, userAccountsService: UserAccountsService) {\n    super();\n    this.config = config;\n    this.strategies = strategies;\n    this.userAccountsService = userAccountsService;\n  }\n\n  /**\n   * @param {string} strategy\n   * @param {Object} options\n   * @param {string} [options.redirectUri]\n   * @param {string} [options.scope]\n   * Space-delimited set of permissions that the application requests.\n   * @param {string} [options.state]\n   * Any string that might be useful to your application upon receipt of the response\n   * @param {string} [options.grantType]\n   * @param {string} [options.accessType = 'online']\n   * online or offline\n   * @param {string} [options.prompt]\n   * Space-delimited, case-sensitive list of prompts to present the user.\n   * Values: none, consent, select_account\n   * @param {string} [options.loginHint] email address or sub identifier\n   * @param {boolean} [options.includeGrantedScopes]\n   * If this is provided with the value true, and the authorization request is granted,\n   * the authorization will include any previous authorizations granted\n   * to this user/application combination for other scopes\n   * @returns {string}\n   */\n  generateAuthUrl(strategy: string, options: GenerateAuthUrlOptions = {}) {\n    logger.debug('generateAuthUrl', { strategy, options });\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2':\n        return strategyInstance.oauth2.authorizationCode.authorizeURL({\n          redirect_uri: options.redirectUri,\n          scope: options.scope,\n          state: options.state,\n          grant_type: options.grantType,\n          access_type: options.accessType,\n          login_hint: options.loginHint,\n          include_granted_scopes: options.includeGrantedScopes,\n        });\n    }\n  }\n\n  getTokens(strategy: string, options: GetTokensOptions = {}) {\n    logger.debug('getTokens', { strategy, options });\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2':\n        return promiseCallback((done) => {\n          strategyInstance.oauth2.authorizationCode.getToken({\n            code: options.code,\n            redirect_uri: options.redirectUri,\n          }, done);\n        }).then(result => (\n          result && {\n            accessToken: result.access_token,\n            refreshToken: result.refresh_token,\n            tokenType: result.token_type,\n            expiresIn: result.expires_in,\n            expireDate: (() => {\n              const d = new Date();\n              d.setTime(d.getTime() + (result.expires_in * 1000));\n              return d;\n            })(),\n            idToken: result.id_token,\n          }\n          // return strategyInstance.accessToken.create(result);\n      ));\n    }\n  }\n\n  refreshToken(strategy: string, tokens) {\n    logger.debug('refreshToken', { strategy });\n    if (!tokens.refreshToken) {\n      throw new Error('Missing refresh token');\n    }\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2': {\n        const token = strategyInstance.oauth2.accessToken.create({\n          refresh_token: tokens.refreshToken,\n        });\n        return promiseCallback(done => token.refresh(done))\n          .then((result) => {\n            const tokens = result.token;\n            return result && {\n              accessToken: tokens.access_token,\n              tokenType: tokens.token_type,\n              expiresIn: tokens.expires_in,\n              expireDate: (() => {\n                const d = new Date();\n                d.setTime(d.getTime() + (tokens.expires_in * 1000));\n                return d;\n              })(),\n              idToken: tokens.id_token,\n            };\n          });\n      }\n    }\n  }\n\n  redirectUri(ctx, strategy: string) {\n    const host = `http${this.config.get('allowHttps') ? 's' : ''}://${ctx.request.host}`;\n    return `${host}${ctx.urlGenerator('loginResponse', { strategy })}`;\n  }\n\n  /**\n   *\n   * @param {Koa.Context} ctx\n   * @param {string} strategy\n   * @param {string} [refreshToken]\n   * @param {string} [scopeKey='login']\n   * @param user\n   * @param accountId\n   * @returns {*}\n   */\n  async redirectAuthUrl(\n    ctx:Object,\n    strategy:string,\n    refreshToken:?string,\n    scopeKey: ?string,\n    user,\n    accountId,\n  ) {\n    logger.debug('redirectAuthUrl', { strategy, scopeKey, refreshToken });\n    const state = await randomHex(8);\n    const isLoginAccess = !scopeKey || scopeKey === 'login';\n    const scope = this.userAccountsService.getScope(strategy, scopeKey || 'login', user, accountId);\n\n    ctx.cookies.set(`auth_${strategy}_${state}`, JSON.stringify({\n      scopeKey,\n      scope,\n      isLoginAccess,\n    }), {\n      maxAge: 10 * 60 * 1000,\n      httpOnly: true,\n      secure: this.config.get('allowHttps'),\n    });\n    const redirectUri = this.generateAuthUrl(strategy, {\n      redirectUri: this.redirectUri(ctx, strategy),\n      scope,\n      state,\n      accessType: refreshToken ? 'offline' : 'online',\n    });\n\n    return await ctx.redirect(redirectUri);\n  }\n\n  /**\n   * @param {Koa.Context} ctx\n   * @param {string} strategy\n   * @param {boolean} isConnected\n   * @returns {*}\n   */\n  async accessResponse(ctx, strategy: string, isConnected: ?boolean) {\n    if (ctx.query.error) {\n      const error = new Error(ctx.query.error);\n      error.status = 403;\n      error.expose = true;\n      throw error;\n    }\n\n    const code = ctx.query.code;\n    const state = ctx.query.state;\n    const cookieName = `auth_${strategy}_${state}`;\n    let cookie = ctx.cookies.get(cookieName);\n    ctx.cookies.set(cookieName, '', { expires: new Date(1) });\n    if (!cookie) {\n      throw new Error('No cookie for this state');\n    }\n\n    cookie = JSON.parse(cookie);\n    if (!cookie || !cookie.scope) {\n      throw new Error('Unexpected cookie value');\n    }\n\n    if (!cookie.isLoginAccess) {\n      if (!isConnected) {\n        throw new Error('You are not connected');\n      }\n    }\n\n    const tokens = await this.getTokens(strategy, {\n      code,\n      redirectUri: this.redirectUri(ctx, strategy),\n    });\n\n    if (cookie.isLoginAccess) {\n      const user = await this.userAccountsService.findOrCreateFromGoogle(\n        strategy,\n        tokens,\n        cookie.scope,\n        cookie.scopeKey,\n      );\n      return user;\n    }\n\n    ctx.cookies.set(cookieName, '', { expires: new Date(1) });\n    const connectedUser = ctx.state.connected;\n    await this.userAccountsService.update(\n      connectedUser,\n      strategy,\n      tokens,\n      cookie.scope,\n      cookie.scopeKey,\n    );\n    return connectedUser;\n  }\n\n  refreshAccountTokens(user, account) {\n    if (account.tokenExpireDate && account.tokenExpireDate.getTime() > Date.now()) {\n      return Promise.resolve(false);\n    }\n    return this.refreshToken(account.provider, {\n      accessToken: account.accessToken,\n      refreshToken: account.refreshToken,\n    }).then((tokens) => {\n      if (!tokens) {\n        // serviceGoogle.updateFields({ accessToken:null, refreshToken:null, status: .OUTDATED });\n        return false;\n      }\n      account.accessToken = tokens.accessToken;\n      account.tokenExpireDate = tokens.expireDate;\n      return this.userAccountsService.updateAccount(user, account).then(() => true);\n    });\n  }\n}\n"]}