{"version":3,"sources":["../../src/services/AuthenticationService.js"],"names":["logger","AuthenticationService","constructor","config","strategies","userAccountsService","generateAuthUrl","strategy","options","debug","strategyInstance","type","oauth2","authorizationCode","authorizeURL","redirect_uri","redirectUri","scope","state","grant_type","grantType","access_type","accessType","login_hint","loginHint","include_granted_scopes","includeGrantedScopes","getTokens","done","getToken","code","then","result","accessToken","access_token","refreshToken","refresh_token","tokenType","token_type","expiresIn","expires_in","expireDate","d","Date","setTime","getTime","idToken","id_token","tokens","Error","token","create","refresh","ctx","host","get","request","urlGenerator","redirectAuthUrl","scopeKey","user","accountId","getScope","cookies","set","JSON","stringify","isLoginAccess","maxAge","httpOnly","secure","redirect","accessResponse","isConnected","query","error","status","expose","cookieName","cookie","expires","parse","findOrCreateFromGoogle","connectedUser","connected","update","refreshAccountTokens","account","tokenExpireDate","now","Promise","resolve","provider","updateAccount"],"mappings":"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","file":"AuthenticationService.js","sourcesContent":["/* eslint camelcase: 'off', max-lines: 'off' */\nimport EventEmitter from 'events';\nimport promiseCallback from 'promise-callback-factory';\nimport Logger from 'nightingale-logger';\nimport UserAccountsService from './user/UserAccountsService';\nimport { randomHex } from '../utils/generators';\n\nconst logger = new Logger('alp:auth:authentication');\n\ntype GenerateAuthUrlOptionsType = {\n  redirectUri?: string,\n  scope?: string,\n  state?: string,\n  grantType?: string,\n  accessType?: string,\n  prompt?: string,\n  loginHint?: string,\n  includeGrantedScopes?: boolean,\n};\n\ntype GetTokensOptionsType = {\n  code: string,\n  redirectUri: string,\n};\n\nexport default class AuthenticationService extends EventEmitter {\n  config: Object;\n  strategies: Object;\n  userAccountsService: UserAccountsService;\n\n  constructor(config, strategies: Object, userAccountsService: UserAccountsService) {\n    super();\n    this.config = config;\n    this.strategies = strategies;\n    this.userAccountsService = userAccountsService;\n  }\n\n  /**\n   * @param {string} strategy\n   * @param {Object} options\n   * @param {string} [options.redirectUri]\n   * @param {string} [options.scope]\n   * Space-delimited set of permissions that the application requests.\n   * @param {string} [options.state]\n   * Any string that might be useful to your application upon receipt of the response\n   * @param {string} [options.grantType]\n   * @param {string} [options.accessType = 'online']\n   * online or offline\n   * @param {string} [options.prompt]\n   * Space-delimited, case-sensitive list of prompts to present the user.\n   * Values: none, consent, select_account\n   * @param {string} [options.loginHint] email address or sub identifier\n   * @param {boolean} [options.includeGrantedScopes]\n   * If this is provided with the value true, and the authorization request is granted,\n   * the authorization will include any previous authorizations granted\n   * to this user/application combination for other scopes\n   * @returns {string}\n   */\n  generateAuthUrl(strategy: string, options: GenerateAuthUrlOptionsType = {}) {\n    logger.debug('generateAuthUrl', { strategy, options });\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2':\n        return strategyInstance.oauth2.authorizationCode.authorizeURL({\n          redirect_uri: options.redirectUri,\n          scope: options.scope,\n          state: options.state,\n          grant_type: options.grantType,\n          access_type: options.accessType,\n          login_hint: options.loginHint,\n          include_granted_scopes: options.includeGrantedScopes,\n        });\n    }\n  }\n\n  getTokens(strategy: string, options: GetTokensOptionsType = {}) {\n    logger.debug('getTokens', { strategy, options });\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2':\n        return promiseCallback(done => {\n          strategyInstance.oauth2.authorizationCode.getToken(\n            {\n              code: options.code,\n              redirect_uri: options.redirectUri,\n            },\n            done,\n          );\n        }).then(\n          result =>\n            result && {\n              accessToken: result.access_token,\n              refreshToken: result.refresh_token,\n              tokenType: result.token_type,\n              expiresIn: result.expires_in,\n              expireDate: (() => {\n                const d = new Date();\n                d.setTime(d.getTime() + result.expires_in * 1000);\n                return d;\n              })(),\n              idToken: result.id_token,\n            },\n          // return strategyInstance.accessToken.create(result);\n        );\n    }\n  }\n\n  refreshToken(strategy: string, tokens) {\n    logger.debug('refreshToken', { strategy });\n    if (!tokens.refreshToken) {\n      throw new Error('Missing refresh token');\n    }\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2': {\n        const token = strategyInstance.oauth2.accessToken.create({\n          refresh_token: tokens.refreshToken,\n        });\n        return promiseCallback(done => token.refresh(done)).then(result => {\n          const tokens = result.token;\n          return (\n            result && {\n              accessToken: tokens.access_token,\n              tokenType: tokens.token_type,\n              expiresIn: tokens.expires_in,\n              expireDate: (() => {\n                const d = new Date();\n                d.setTime(d.getTime() + tokens.expires_in * 1000);\n                return d;\n              })(),\n              idToken: tokens.id_token,\n            }\n          );\n        });\n      }\n    }\n  }\n\n  redirectUri(ctx, strategy: string) {\n    const host = `http${this.config.get('allowHttps') ? 's' : ''}://${ctx.request.host}`;\n    return `${host}${ctx.urlGenerator('loginResponse', { strategy })}`;\n  }\n\n  /**\n   *\n   * @param {Koa.Context} ctx\n   * @param {string} strategy\n   * @param {string} [refreshToken]\n   * @param {string} [scopeKey='login']\n   * @param user\n   * @param accountId\n   * @returns {*}\n   */\n  async redirectAuthUrl(\n    ctx: Object,\n    strategy: string,\n    refreshToken: ?string,\n    scopeKey: ?string,\n    user,\n    accountId,\n  ) {\n    logger.debug('redirectAuthUrl', { strategy, scopeKey, refreshToken });\n    const state = await randomHex(8);\n    const isLoginAccess = !scopeKey || scopeKey === 'login';\n    const scope = this.userAccountsService.getScope(strategy, scopeKey || 'login', user, accountId);\n\n    ctx.cookies.set(\n      `auth_${strategy}_${state}`,\n      JSON.stringify({\n        scopeKey,\n        scope,\n        isLoginAccess,\n      }),\n      {\n        maxAge: 10 * 60 * 1000,\n        httpOnly: true,\n        secure: this.config.get('allowHttps'),\n      },\n    );\n    const redirectUri = this.generateAuthUrl(strategy, {\n      redirectUri: this.redirectUri(ctx, strategy),\n      scope,\n      state,\n      accessType: refreshToken ? 'offline' : 'online',\n    });\n\n    return ctx.redirect(redirectUri);\n  }\n\n  /**\n   * @param {Koa.Context} ctx\n   * @param {string} strategy\n   * @param {boolean} isConnected\n   * @returns {*}\n   */\n  async accessResponse(ctx, strategy: string, isConnected: ?boolean) {\n    if (ctx.query.error) {\n      const error = new Error(ctx.query.error);\n      error.status = 403;\n      error.expose = true;\n      throw error;\n    }\n\n    const code = ctx.query.code;\n    const state = ctx.query.state;\n    const cookieName = `auth_${strategy}_${state}`;\n    let cookie = ctx.cookies.get(cookieName);\n    ctx.cookies.set(cookieName, '', { expires: new Date(1) });\n    if (!cookie) {\n      throw new Error('No cookie for this state');\n    }\n\n    cookie = JSON.parse(cookie);\n    if (!cookie || !cookie.scope) {\n      throw new Error('Unexpected cookie value');\n    }\n\n    if (!cookie.isLoginAccess) {\n      if (!isConnected) {\n        throw new Error('You are not connected');\n      }\n    }\n\n    const tokens = await this.getTokens(strategy, {\n      code,\n      redirectUri: this.redirectUri(ctx, strategy),\n    });\n\n    if (cookie.isLoginAccess) {\n      const user = await this.userAccountsService.findOrCreateFromGoogle(\n        strategy,\n        tokens,\n        cookie.scope,\n        cookie.scopeKey,\n      );\n      return user;\n    }\n\n    ctx.cookies.set(cookieName, '', { expires: new Date(1) });\n    const connectedUser = ctx.state.connected;\n    await this.userAccountsService.update(\n      connectedUser,\n      strategy,\n      tokens,\n      cookie.scope,\n      cookie.scopeKey,\n    );\n    return connectedUser;\n  }\n\n  refreshAccountTokens(user, account) {\n    if (account.tokenExpireDate && account.tokenExpireDate.getTime() > Date.now()) {\n      return Promise.resolve(false);\n    }\n    return this.refreshToken(account.provider, {\n      accessToken: account.accessToken,\n      refreshToken: account.refreshToken,\n    }).then(tokens => {\n      if (!tokens) {\n        // serviceGoogle.updateFields({ accessToken:null, refreshToken:null, status: .OUTDATED });\n        return false;\n      }\n      account.accessToken = tokens.accessToken;\n      account.tokenExpireDate = tokens.expireDate;\n      return this.userAccountsService.updateAccount(user, account).then(() => true);\n    });\n  }\n}\n"]}