{"version":3,"sources":["../../src/services/AuthenticationService.js"],"names":["logger","AuthenticationService","constructor","config","strategies","userAccountsService","generateAuthUrl","strategy","options","debug","strategyInstance","type","oauth2","authorizationCode","authorizeURL","redirect_uri","redirectUri","scope","state","grant_type","grantType","access_type","accessType","login_hint","loginHint","include_granted_scopes","includeGrantedScopes","getTokens","done","getToken","code","then","result","accessToken","access_token","refreshToken","refresh_token","tokenType","token_type","expiresIn","expires_in","expireDate","d","Date","setTime","getTime","idToken","id_token","tokens","Error","token","create","refresh","ctx","host","get","request","urlGenerator","redirectAuthUrl","scopeKey","user","accountId","getScope","cookies","set","JSON","stringify","isLoginAccess","maxAge","httpOnly","secure","redirect","accessResponse","isConnected","query","error","status","expose","cookieName","cookie","expires","parse","findOrCreateFromGoogle","connectedUser","connected","update","refreshAccountTokens","account","tokenExpireDate","now","Promise","resolve","provider","updateAccount"],"mappings":"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","file":"AuthenticationService.js","sourcesContent":["/* eslint camelcase: \"off\" */\nimport EventEmitter from 'events';\nimport promiseCallback from 'promise-callback-factory';\nimport Logger from 'nightingale-logger';\nimport UserAccountsService from './user/UserAccountsService';\nimport { randomHex } from '../utils/generators';\n\nconst logger = new Logger('alp-auth.services.authentication');\n\ntype GenerateAuthUrlOptions = {\n  redirectUri?: string,\n  scope?: string,\n  state?: string,\n  grantType?: string,\n  accessType?: string,\n  prompt?: string,\n  loginHint?: string,\n  includeGrantedScopes?: boolean,\n}\n\ntype GetTokensOptions = {\n  code: string,\n  redirectUri: string,\n}\n\nexport default class AuthenticationService extends EventEmitter {\n  config: Object;\n  strategies: Object;\n  userAccountsService: UserAccountsService;\n\n  constructor(config, strategies: Object, userAccountsService: UserAccountsService) {\n    super();\n    this.config = config;\n    this.strategies = strategies;\n    this.userAccountsService = userAccountsService;\n  }\n\n  /**\n   * @param {string} strategy\n   * @param {Object} options\n   * @param {string} [options.redirectUri]\n   * @param {string} [options.scope]\n   * Space-delimited set of permissions that the application requests.\n   * @param {string} [options.state]\n   * Any string that might be useful to your application upon receipt of the response\n   * @param {string} [options.grantType]\n   * @param {string} [options.accessType = 'online']\n   * online or offline\n   * @param {string} [options.prompt]\n   * Space-delimited, case-sensitive list of prompts to present the user.\n   * Values: none, consent, select_account\n   * @param {string} [options.loginHint] email address or sub identifier\n   * @param {boolean} [options.includeGrantedScopes]\n   * If this is provided with the value true, and the authorization request is granted,\n   * the authorization will include any previous authorizations granted\n   * to this user/application combination for other scopes\n   * @returns {string}\n   */\n  generateAuthUrl(strategy: string, options: GenerateAuthUrlOptions = {}) {\n    logger.debug('generateAuthUrl', { strategy, options });\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2':\n        return strategyInstance.oauth2.authorizationCode.authorizeURL({\n          redirect_uri: options.redirectUri,\n          scope: options.scope,\n          state: options.state,\n          grant_type: options.grantType,\n          access_type: options.accessType,\n          login_hint: options.loginHint,\n          include_granted_scopes: options.includeGrantedScopes,\n        });\n    }\n  }\n\n  getTokens(strategy: string, options: GetTokensOptions = {}) {\n    logger.debug('getTokens', { strategy, options });\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2':\n        return promiseCallback((done) => {\n          strategyInstance.oauth2.authorizationCode.getToken({\n            code: options.code,\n            redirect_uri: options.redirectUri,\n          }, done);\n        }).then(result => (\n          result && {\n            accessToken: result.access_token,\n            refreshToken: result.refresh_token,\n            tokenType: result.token_type,\n            expiresIn: result.expires_in,\n            expireDate: (() => {\n              const d = new Date();\n              d.setTime(d.getTime() + (result.expires_in * 1000));\n              return d;\n            })(),\n            idToken: result.id_token,\n          }\n          // return strategyInstance.accessToken.create(result);\n      ));\n    }\n  }\n\n  refreshToken(strategy: string, tokens) {\n    logger.debug('refreshToken', { strategy });\n    if (!tokens.refreshToken) {\n      throw new Error('Missing refresh token');\n    }\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2': {\n        const token = strategyInstance.oauth2.accessToken.create({\n          refresh_token: tokens.refreshToken,\n        });\n        return promiseCallback(done => token.refresh(done))\n          .then((result) => {\n            const tokens = result.token;\n            return result && {\n              accessToken: tokens.access_token,\n              tokenType: tokens.token_type,\n              expiresIn: tokens.expires_in,\n              expireDate: (() => {\n                const d = new Date();\n                d.setTime(d.getTime() + (tokens.expires_in * 1000));\n                return d;\n              })(),\n              idToken: tokens.id_token,\n            };\n          });\n      }\n    }\n  }\n\n  redirectUri(ctx, strategy: string) {\n    const host = `http${this.config.get('allowHttps') ? 's' : ''}://${ctx.request.host}`;\n    return `${host}${ctx.urlGenerator('loginResponse', { strategy })}`;\n  }\n\n  /**\n   *\n   * @param {Koa.Context} ctx\n   * @param {string} strategy\n   * @param {string} [refreshToken]\n   * @param {string} [scopeKey='login']\n   * @param user\n   * @param accountId\n   * @returns {*}\n   */\n  async redirectAuthUrl(\n    ctx:Object,\n    strategy:string,\n    refreshToken:?string,\n    scopeKey: ?string,\n    user,\n    accountId,\n  ) {\n    logger.debug('redirectAuthUrl', { strategy, scopeKey, refreshToken });\n    const state = await randomHex(8);\n    const isLoginAccess = !scopeKey || scopeKey === 'login';\n    const scope = this.userAccountsService.getScope(strategy, scopeKey || 'login', user, accountId);\n\n    ctx.cookies.set(`auth_${strategy}_${state}`, JSON.stringify({\n      scopeKey: scopeKey,\n      scope: scope,\n      isLoginAccess: isLoginAccess,\n    }), {\n      maxAge: 10 * 60 * 1000,\n      httpOnly: true,\n      secure: this.config.get('allowHttps'),\n    });\n    const redirectUri = this.generateAuthUrl(strategy, {\n      redirectUri: this.redirectUri(ctx, strategy),\n      scope: scope,\n      state: state,\n      accessType: refreshToken ? 'offline' : 'online',\n    });\n\n    return await ctx.redirect(redirectUri);\n  }\n\n  /**\n   * @param {Koa.Context} ctx\n   * @param {string} strategy\n   * @param {boolean} isConnected\n   * @returns {*}\n   */\n  async accessResponse(ctx, strategy: string, isConnected: ?boolean) {\n    if (ctx.query.error) {\n      const error = new Error(ctx.query.error);\n      error.status = 403;\n      error.expose = true;\n      throw error;\n    }\n\n    const code = ctx.query.code;\n    const state = ctx.query.state;\n    const cookieName = `auth_${strategy}_${state}`;\n    let cookie = ctx.cookies.get(cookieName);\n    ctx.cookies.set(cookieName, '', { expires: new Date(1) });\n    if (!cookie) {\n      throw new Error('No cookie for this state');\n    }\n\n    cookie = JSON.parse(cookie);\n    if (!cookie || !cookie.scope) {\n      throw new Error('Unexpected cookie value');\n    }\n\n    if (!cookie.isLoginAccess) {\n      if (!isConnected) {\n        throw new Error('You are not connected');\n      }\n    }\n\n    const tokens = await this.getTokens(strategy, {\n      code: code,\n      redirectUri: this.redirectUri(ctx, strategy),\n    });\n\n    if (cookie.isLoginAccess) {\n      const user = await this.userAccountsService.findOrCreateFromGoogle(\n        strategy,\n        tokens,\n        cookie.scope,\n        cookie.scopeKey,\n      );\n      return user;\n    }\n\n    ctx.cookies.set(cookieName, '', { expires: new Date(1) });\n    const connectedUser = ctx.state.connected;\n    await this.userAccountsService.update(\n      connectedUser,\n      strategy,\n      tokens,\n      cookie.scope,\n      cookie.scopeKey,\n    );\n    return connectedUser;\n  }\n\n  refreshAccountTokens(user, account) {\n    if (account.tokenExpireDate && account.tokenExpireDate.getTime() > Date.now()) {\n      return Promise.resolve(false);\n    }\n    return this.refreshToken(account.provider, {\n      accessToken: account.accessToken,\n      refreshToken: account.refreshToken,\n    }).then((tokens) => {\n      if (!tokens) {\n        // serviceGoogle.updateFields({ accessToken:null, refreshToken:null, status: .OUTDATED });\n        return false;\n      }\n      account.accessToken = tokens.accessToken;\n      account.tokenExpireDate = tokens.expireDate;\n      return this.userAccountsService.updateAccount(user, account).then(() => true);\n    });\n  }\n}\n"]}