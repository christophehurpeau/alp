{"version":3,"sources":["../../src/services/AuthenticationService.js"],"names":["logger","GenerateAuthUrlOptions","redirectUri","scope","state","grantType","accessType","prompt","loginHint","includeGrantedScopes","GetTokensOptions","code","AuthenticationService","constructor","config","strategies","userAccountsService","generateAuthUrl","strategy","options","debug","strategyInstance","type","oauth2","authorizationCode","authorizeURL","redirect_uri","grant_type","access_type","login_hint","include_granted_scopes","getTokens","done","getToken","then","result","accessToken","access_token","refreshToken","refresh_token","tokenType","token_type","expiresIn","expires_in","expireDate","d","Date","setTime","getTime","idToken","id_token","tokens","Error","token","create","refresh","ctx","host","get","request","urlGenerator","redirectAuthUrl","scopeKey","user","accountId","getScope","cookies","set","JSON","stringify","isLoginAccess","maxAge","httpOnly","secure","redirect","accessResponse","isConnected","query","error","status","expose","cookieName","cookie","expires","parse","findOrCreateFromGoogle","connectedUser","connected","update","refreshAccountTokens","account","tokenExpireDate","now","Promise","resolve","provider","updateAccount"],"mappings":"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","file":"AuthenticationService.js","sourcesContent":["/* eslint camelcase: \"off\" */\nimport EventEmitter from 'events';\nimport promiseCallback from 'promise-callback-factory';\nimport Logger from 'nightingale-logger';\nimport UserAccountsService from './user/UserAccountsService';\nimport { randomHex } from '../utils/generators';\n\nconst logger = new Logger('alp-auth.services.authentication');\n\ntype GenerateAuthUrlOptions = {\n  redirectUri?: string,\n  scope?: string,\n  state?: string,\n  grantType?: string,\n  accessType?: string,\n  prompt?: string,\n  loginHint?: string,\n  includeGrantedScopes?: boolean,\n}\n\ntype GetTokensOptions = {\n  code: string,\n  redirectUri: string,\n}\n\nexport default class AuthenticationService extends EventEmitter {\n  config: Object;\n  strategies: Object;\n  userAccountsService: UserAccountsService;\n\n  constructor(config, strategies: Object, userAccountsService: UserAccountsService) {\n    super();\n    this.config = config;\n    this.strategies = strategies;\n    this.userAccountsService = userAccountsService;\n  }\n\n  /**\n   * @param {string} strategy\n   * @param {Object} options\n   * @param {string} [options.redirectUri]\n   * @param {string} [options.scope]\n   * Space-delimited set of permissions that the application requests.\n   * @param {string} [options.state]\n   * Any string that might be useful to your application upon receipt of the response\n   * @param {string} [options.grantType]\n   * @param {string} [options.accessType = 'online']\n   * online or offline\n   * @param {string} [options.prompt]\n   * Space-delimited, case-sensitive list of prompts to present the user.\n   * Values: none, consent, select_account\n   * @param {string} [options.loginHint] email address or sub identifier\n   * @param {boolean} [options.includeGrantedScopes]\n   * If this is provided with the value true, and the authorization request is granted,\n   * the authorization will include any previous authorizations granted\n   * to this user/application combination for other scopes\n   * @returns {string}\n   */\n  generateAuthUrl(strategy: string, options: GenerateAuthUrlOptions = {}) {\n    logger.debug('generateAuthUrl', { strategy, options });\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2':\n        return strategyInstance.oauth2.authorizationCode.authorizeURL({\n          redirect_uri: options.redirectUri,\n          scope: options.scope,\n          state: options.state,\n          grant_type: options.grantType,\n          access_type: options.accessType,\n          login_hint: options.loginHint,\n          include_granted_scopes: options.includeGrantedScopes,\n        });\n    }\n  }\n\n  getTokens(strategy: string, options: GetTokensOptions = {}) {\n    logger.debug('getTokens', { strategy, options });\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2':\n        return promiseCallback((done) => {\n          strategyInstance.oauth2.authorizationCode.getToken({\n            code: options.code,\n            redirect_uri: options.redirectUri,\n          }, done);\n        }).then(result => (\n          result && {\n            accessToken: result.access_token,\n            refreshToken: result.refresh_token,\n            tokenType: result.token_type,\n            expiresIn: result.expires_in,\n            expireDate: (() => {\n              const d = new Date();\n              d.setTime(d.getTime() + (result.expires_in * 1000));\n              return d;\n            })(),\n            idToken: result.id_token,\n          }\n          // return strategyInstance.accessToken.create(result);\n      ));\n    }\n  }\n\n  refreshToken(strategy: string, tokens) {\n    logger.debug('refreshToken', { strategy });\n    if (!tokens.refreshToken) {\n      throw new Error('Missing refresh token');\n    }\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2': {\n        const token = strategyInstance.oauth2.accessToken.create({\n          refresh_token: tokens.refreshToken,\n        });\n        return promiseCallback(done => token.refresh(done))\n          .then((result) => {\n            const tokens = result.token;\n            return result && {\n              accessToken: tokens.access_token,\n              tokenType: tokens.token_type,\n              expiresIn: tokens.expires_in,\n              expireDate: (() => {\n                const d = new Date();\n                d.setTime(d.getTime() + (tokens.expires_in * 1000));\n                return d;\n              })(),\n              idToken: tokens.id_token,\n            };\n          });\n      }\n    }\n  }\n\n  redirectUri(ctx, strategy: string) {\n    const host = `http${this.config.get('allowHttps') ? 's' : ''}://${ctx.request.host}`;\n    return `${host}${ctx.urlGenerator('loginResponse', { strategy })}`;\n  }\n\n  /**\n   *\n   * @param {Koa.Context} ctx\n   * @param {string} strategy\n   * @param {string} [refreshToken]\n   * @param {string} [scopeKey='login']\n   * @param user\n   * @param accountId\n   * @returns {*}\n   */\n  async redirectAuthUrl(\n    ctx:Object,\n    strategy:string,\n    refreshToken:?string,\n    scopeKey: ?string,\n    user,\n    accountId,\n  ) {\n    logger.debug('redirectAuthUrl', { strategy, scopeKey, refreshToken });\n    const state = await randomHex(8);\n    const isLoginAccess = !scopeKey || scopeKey === 'login';\n    const scope = this.userAccountsService.getScope(strategy, scopeKey || 'login', user, accountId);\n\n    ctx.cookies.set(`auth_${strategy}_${state}`, JSON.stringify({\n      scopeKey: scopeKey,\n      scope: scope,\n      isLoginAccess: isLoginAccess,\n    }), {\n      maxAge: 10 * 60 * 1000,\n      httpOnly: true,\n      secure: this.config.get('allowHttps'),\n    });\n    const redirectUri = this.generateAuthUrl(strategy, {\n      redirectUri: this.redirectUri(ctx, strategy),\n      scope: scope,\n      state: state,\n      accessType: refreshToken ? 'offline' : 'online',\n    });\n\n    return await ctx.redirect(redirectUri);\n  }\n\n  /**\n   * @param {Koa.Context} ctx\n   * @param {string} strategy\n   * @param {boolean} isConnected\n   * @returns {*}\n   */\n  async accessResponse(ctx, strategy: string, isConnected: ?boolean) {\n    if (ctx.query.error) {\n      const error = new Error(ctx.query.error);\n      error.status = 403;\n      error.expose = true;\n      throw error;\n    }\n\n    const code = ctx.query.code;\n    const state = ctx.query.state;\n    const cookieName = `auth_${strategy}_${state}`;\n    let cookie = ctx.cookies.get(cookieName);\n    ctx.cookies.set(cookieName, '', { expires: new Date(1) });\n    if (!cookie) {\n      throw new Error('No cookie for this state');\n    }\n\n    cookie = JSON.parse(cookie);\n    if (!cookie || !cookie.scope) {\n      throw new Error('Unexpected cookie value');\n    }\n\n    if (!cookie.isLoginAccess) {\n      if (!isConnected) {\n        throw new Error('You are not connected');\n      }\n    }\n\n    const tokens = await this.getTokens(strategy, {\n      code: code,\n      redirectUri: this.redirectUri(ctx, strategy),\n    });\n\n    if (cookie.isLoginAccess) {\n      const user = await this.userAccountsService.findOrCreateFromGoogle(\n        strategy,\n        tokens,\n        cookie.scope,\n        cookie.scopeKey,\n      );\n      return user;\n    }\n\n    ctx.cookies.set(cookieName, '', { expires: new Date(1) });\n    const connectedUser = ctx.state.connected;\n    await this.userAccountsService.update(\n      connectedUser,\n      strategy,\n      tokens,\n      cookie.scope,\n      cookie.scopeKey,\n    );\n    return connectedUser;\n  }\n\n  refreshAccountTokens(user, account) {\n    if (account.tokenExpireDate && account.tokenExpireDate.getTime() > Date.now()) {\n      return Promise.resolve(false);\n    }\n    return this.refreshToken(account.provider, {\n      accessToken: account.accessToken,\n      refreshToken: account.refreshToken,\n    }).then((tokens) => {\n      if (!tokens) {\n        // serviceGoogle.updateFields({ accessToken:null, refreshToken:null, status: .OUTDATED });\n        return false;\n      }\n      account.accessToken = tokens.accessToken;\n      account.tokenExpireDate = tokens.expireDate;\n      return this.userAccountsService.updateAccount(user, account).then(() => true);\n    });\n  }\n}\n"]}