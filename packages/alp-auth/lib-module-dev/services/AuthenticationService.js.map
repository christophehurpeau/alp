{"version":3,"sources":["../../src/services/AuthenticationService.js"],"names":["EventEmitter","promiseCallback","Logger","UserAccountsService","randomHex","logger","AuthenticationService","config","strategies","userAccountsService","strategy","options","debug","strategyInstance","type","oauth2","authorizationCode","authorizeURL","redirect_uri","redirectUri","scope","state","grant_type","grantType","access_type","accessType","login_hint","loginHint","include_granted_scopes","includeGrantedScopes","done","getToken","code","then","result","accessToken","access_token","refreshToken","refresh_token","tokenType","token_type","expiresIn","expires_in","expireDate","d","Date","setTime","getTime","idToken","id_token","tokens","Error","token","create","refresh","ctx","host","get","request","urlGenerator","scopeKey","user","accountId","isLoginAccess","getScope","cookies","set","JSON","stringify","maxAge","httpOnly","secure","generateAuthUrl","redirect","isConnected","query","error","status","expose","cookieName","cookie","expires","parse","getTokens","findOrCreateFromGoogle","connectedUser","connected","update","account","tokenExpireDate","now","Promise","resolve","provider","updateAccount"],"mappings":"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","file":"AuthenticationService.js","sourcesContent":["/* eslint camelcase: 'off', max-lines: 'off' */\nimport EventEmitter from 'events';\nimport promiseCallback from 'promise-callback-factory';\nimport Logger from 'nightingale-logger';\nimport UserAccountsService from './user/UserAccountsService';\nimport { randomHex } from '../utils/generators';\n\nconst logger = new Logger('alp:auth:authentication');\n\ntype GenerateAuthUrlOptionsType = {\n  redirectUri?: string,\n  scope?: string,\n  state?: string,\n  grantType?: string,\n  accessType?: string,\n  prompt?: string,\n  loginHint?: string,\n  includeGrantedScopes?: boolean,\n}\n\ntype GetTokensOptionsType = {\n  code: string,\n  redirectUri: string,\n}\n\nexport default class AuthenticationService extends EventEmitter {\n  config: Object;\n  strategies: Object;\n  userAccountsService: UserAccountsService;\n\n  constructor(config, strategies: Object, userAccountsService: UserAccountsService) {\n    super();\n    this.config = config;\n    this.strategies = strategies;\n    this.userAccountsService = userAccountsService;\n  }\n\n  /**\n   * @param {string} strategy\n   * @param {Object} options\n   * @param {string} [options.redirectUri]\n   * @param {string} [options.scope]\n   * Space-delimited set of permissions that the application requests.\n   * @param {string} [options.state]\n   * Any string that might be useful to your application upon receipt of the response\n   * @param {string} [options.grantType]\n   * @param {string} [options.accessType = 'online']\n   * online or offline\n   * @param {string} [options.prompt]\n   * Space-delimited, case-sensitive list of prompts to present the user.\n   * Values: none, consent, select_account\n   * @param {string} [options.loginHint] email address or sub identifier\n   * @param {boolean} [options.includeGrantedScopes]\n   * If this is provided with the value true, and the authorization request is granted,\n   * the authorization will include any previous authorizations granted\n   * to this user/application combination for other scopes\n   * @returns {string}\n   */\n  generateAuthUrl(strategy: string, options: GenerateAuthUrlOptionsType = {}) {\n    logger.debug('generateAuthUrl', { strategy, options });\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2':\n        return strategyInstance.oauth2.authorizationCode.authorizeURL({\n          redirect_uri: options.redirectUri,\n          scope: options.scope,\n          state: options.state,\n          grant_type: options.grantType,\n          access_type: options.accessType,\n          login_hint: options.loginHint,\n          include_granted_scopes: options.includeGrantedScopes,\n        });\n    }\n  }\n\n  getTokens(strategy: string, options: GetTokensOptionsType = {}) {\n    logger.debug('getTokens', { strategy, options });\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2':\n        return promiseCallback((done) => {\n          strategyInstance.oauth2.authorizationCode.getToken({\n            code: options.code,\n            redirect_uri: options.redirectUri,\n          }, done);\n        }).then(result => (\n          result && {\n            accessToken: result.access_token,\n            refreshToken: result.refresh_token,\n            tokenType: result.token_type,\n            expiresIn: result.expires_in,\n            expireDate: (() => {\n              const d = new Date();\n              d.setTime(d.getTime() + (result.expires_in * 1000));\n              return d;\n            })(),\n            idToken: result.id_token,\n          }\n          // return strategyInstance.accessToken.create(result);\n      ));\n    }\n  }\n\n  refreshToken(strategy: string, tokens) {\n    logger.debug('refreshToken', { strategy });\n    if (!tokens.refreshToken) {\n      throw new Error('Missing refresh token');\n    }\n    const strategyInstance = this.strategies[strategy];\n    switch (strategyInstance.type) {\n      case 'oauth2': {\n        const token = strategyInstance.oauth2.accessToken.create({\n          refresh_token: tokens.refreshToken,\n        });\n        return promiseCallback(done => token.refresh(done))\n          .then((result) => {\n            const tokens = result.token;\n            return result && {\n              accessToken: tokens.access_token,\n              tokenType: tokens.token_type,\n              expiresIn: tokens.expires_in,\n              expireDate: (() => {\n                const d = new Date();\n                d.setTime(d.getTime() + (tokens.expires_in * 1000));\n                return d;\n              })(),\n              idToken: tokens.id_token,\n            };\n          });\n      }\n    }\n  }\n\n  redirectUri(ctx, strategy: string) {\n    const host = `http${this.config.get('allowHttps') ? 's' : ''}://${ctx.request.host}`;\n    return `${host}${ctx.urlGenerator('loginResponse', { strategy })}`;\n  }\n\n  /**\n   *\n   * @param {Koa.Context} ctx\n   * @param {string} strategy\n   * @param {string} [refreshToken]\n   * @param {string} [scopeKey='login']\n   * @param user\n   * @param accountId\n   * @returns {*}\n   */\n  async redirectAuthUrl(\n    ctx:Object,\n    strategy:string,\n    refreshToken:?string,\n    scopeKey: ?string,\n    user,\n    accountId,\n  ) {\n    logger.debug('redirectAuthUrl', { strategy, scopeKey, refreshToken });\n    const state = await randomHex(8);\n    const isLoginAccess = !scopeKey || scopeKey === 'login';\n    const scope = this.userAccountsService.getScope(strategy, scopeKey || 'login', user, accountId);\n\n    ctx.cookies.set(`auth_${strategy}_${state}`, JSON.stringify({\n      scopeKey,\n      scope,\n      isLoginAccess,\n    }), {\n      maxAge: 10 * 60 * 1000,\n      httpOnly: true,\n      secure: this.config.get('allowHttps'),\n    });\n    const redirectUri = this.generateAuthUrl(strategy, {\n      redirectUri: this.redirectUri(ctx, strategy),\n      scope,\n      state,\n      accessType: refreshToken ? 'offline' : 'online',\n    });\n\n    return await ctx.redirect(redirectUri);\n  }\n\n  /**\n   * @param {Koa.Context} ctx\n   * @param {string} strategy\n   * @param {boolean} isConnected\n   * @returns {*}\n   */\n  async accessResponse(ctx, strategy: string, isConnected: ?boolean) {\n    if (ctx.query.error) {\n      const error = new Error(ctx.query.error);\n      error.status = 403;\n      error.expose = true;\n      throw error;\n    }\n\n    const code = ctx.query.code;\n    const state = ctx.query.state;\n    const cookieName = `auth_${strategy}_${state}`;\n    let cookie = ctx.cookies.get(cookieName);\n    ctx.cookies.set(cookieName, '', { expires: new Date(1) });\n    if (!cookie) {\n      throw new Error('No cookie for this state');\n    }\n\n    cookie = JSON.parse(cookie);\n    if (!cookie || !cookie.scope) {\n      throw new Error('Unexpected cookie value');\n    }\n\n    if (!cookie.isLoginAccess) {\n      if (!isConnected) {\n        throw new Error('You are not connected');\n      }\n    }\n\n    const tokens = await this.getTokens(strategy, {\n      code,\n      redirectUri: this.redirectUri(ctx, strategy),\n    });\n\n    if (cookie.isLoginAccess) {\n      const user = await this.userAccountsService.findOrCreateFromGoogle(\n        strategy,\n        tokens,\n        cookie.scope,\n        cookie.scopeKey,\n      );\n      return user;\n    }\n\n    ctx.cookies.set(cookieName, '', { expires: new Date(1) });\n    const connectedUser = ctx.state.connected;\n    await this.userAccountsService.update(\n      connectedUser,\n      strategy,\n      tokens,\n      cookie.scope,\n      cookie.scopeKey,\n    );\n    return connectedUser;\n  }\n\n  refreshAccountTokens(user, account) {\n    if (account.tokenExpireDate && account.tokenExpireDate.getTime() > Date.now()) {\n      return Promise.resolve(false);\n    }\n    return this.refreshToken(account.provider, {\n      accessToken: account.accessToken,\n      refreshToken: account.refreshToken,\n    }).then((tokens) => {\n      if (!tokens) {\n        // serviceGoogle.updateFields({ accessToken:null, refreshToken:null, status: .OUTDATED });\n        return false;\n      }\n      account.accessToken = tokens.accessToken;\n      account.tokenExpireDate = tokens.expireDate;\n      return this.userAccountsService.updateAccount(user, account).then(() => true);\n    });\n  }\n}\n"]}