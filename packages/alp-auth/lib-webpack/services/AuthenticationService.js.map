{"version":3,"sources":["../../src/services/AuthenticationService.js"],"names":[],"mappings":"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","file":"AuthenticationService.js","sourcesContent":["/* eslint camelcase: \"off\" */\nimport EventEmitter from 'events';\nimport promiseCallback from 'promise-callback-factory';\nimport Logger from 'nightingale-logger';\nimport UserAccountsService from './user/UserAccountsService';\nimport { randomHex } from '../utils/generators';\n\nconst logger = new Logger('alp-auth.services.authentication');\n\ntype GenerateAuthUrlOptions = {\n    redirectUri?: string,\n    scope?: string,\n    state?: string,\n    grantType?: string,\n    accessType?: string,\n    prompt?: string,\n    loginHint?: string,\n    includeGrantedScopes?: boolean,\n}\n\ntype GetTokensOptions = {\n    code: string,\n    redirectUri: string,\n}\n\nexport default class AuthenticationService extends EventEmitter {\n    config: Object;\n    strategies: Object;\n    userAccountsService: UserAccountsService;\n\n\n    constructor(config, strategies: Object, userAccountsService: UserAccountsService) {\n        super();\n        this.config = config;\n        this.strategies = strategies;\n        this.userAccountsService = userAccountsService;\n    }\n\n    /**\n     *\n     * @param {string} strategy\n     * @param {Object} options\n     * @param {string} [options.redirectUri]\n     * @param {string} [options.scope] Space-delimited set of permissions that the application requests.\n     * @param {string} [options.state] Any string that might be useful to your application upon receipt of the response\n     * @param {string} [options.grantType]\n     * @param {string} [options.accessType = 'online'] online or offline\n     * @param {string} [options.prompt] Space-delimited, case-sensitive list of prompts to present the user. values: none, consent, select_account\n     * @param {string} [options.loginHint] email address or sub identifier\n     * @param {boolean} [options.includeGrantedScopes] If this is provided with the value true, and the authorization request is granted, the authorization will include any previous authorizations granted to this user/application combination for other scopes\n     * @returns {string}\n     */\n    generateAuthUrl(strategy: string, options: GenerateAuthUrlOptions = {}) {\n        logger.debug('generateAuthUrl', { strategy, options });\n        const strategyInstance = this.strategies[strategy];\n        switch (strategyInstance.type) {\n            case 'oauth2':\n                return strategyInstance.oauth2.authCode.authorizeURL({\n                    redirect_uri: options.redirectUri,\n                    scope: options.scope,\n                    state: options.state,\n                    grant_type: options.grantType,\n                    access_type: options.accessType,\n                    login_hint: options.loginHint,\n                    include_granted_scopes: options.includeGrantedScopes,\n                });\n\n        }\n    }\n\n\n    getTokens(strategy: string, options: GetTokensOptions = {}) {\n        logger.debug('getTokens', { strategy, options });\n        const strategyInstance = this.strategies[strategy];\n        switch (strategyInstance.type) {\n            case 'oauth2':\n                return promiseCallback((done) => {\n                    strategyInstance.oauth2.authCode.getToken({\n                        code: options.code,\n                        redirect_uri: options.redirectUri,\n                    }, done);\n                }).then(result => (\n                    result && {\n                        accessToken: result.access_token,\n                        refreshToken: result.refresh_token,\n                        tokenType: result.token_type,\n                        expiresIn: result.expires_in,\n                        expireDate: (() => {\n                            const d = new Date();\n                            d.setTime(d.getTime() + (result.expires_in * 1000));\n                            return d;\n                        })(),\n                        idToken: result.id_token,\n                    }\n                    // return strategyInstance.accessToken.create(result);\n                ));\n        }\n    }\n\n    refreshToken(strategy: string, tokens) {\n        logger.debug('refreshToken', { strategy });\n        if (!tokens.refreshToken) {\n            throw new Error('Missing refresh token');\n        }\n        const strategyInstance = this.strategies[strategy];\n        switch (strategyInstance.type) {\n            case 'oauth2': {\n                const token = strategyInstance.oauth2.accessToken.create({\n                    refresh_token: tokens.refreshToken,\n                });\n                return promiseCallback(done => token.refresh(done))\n                    .then((result) => {\n                        const tokens = result.token;\n                        return result && {\n                            accessToken: tokens.access_token,\n                            tokenType: tokens.token_type,\n                            expiresIn: tokens.expires_in,\n                            expireDate: (() => {\n                                const d = new Date();\n                                d.setTime(d.getTime() + (tokens.expires_in * 1000));\n                                return d;\n                            })(),\n                            idToken: tokens.id_token,\n                        };\n                    });\n            }\n        }\n    }\n\n    redirectUri(ctx, strategy: string) {\n        const host = `http${this.config.get('allowHttps') ? 's' : ''}://${ctx.request.host}`;\n        return `${host}${ctx.urlGenerator('loginResponse', { strategy })}`;\n    }\n\n    /**\n     *\n     * @param {Koa.Context} ctx\n     * @param {string} strategy\n     * @param {string} [refreshToken]\n     * @param {string} [scopeKey='login']\n     * @param user\n     * @param accountId\n     * @returns {*}\n     */\n    async redirectAuthUrl(\n        ctx:Object,\n        strategy:string,\n        refreshToken:?string,\n        scopeKey: ?string,\n        user,\n        accountId\n    ) {\n        logger.debug('redirectAuthUrl', { strategy, scopeKey, refreshToken });\n        const state = await randomHex(8);\n        const isLoginAccess = !scopeKey || scopeKey === 'login';\n        const scope = this.userAccountsService.getScope(strategy, scopeKey || 'login', user, accountId);\n\n        ctx.cookies.set(`auth_${strategy}_${state}`, JSON.stringify({\n            scopeKey: scopeKey,\n            scope: scope,\n            isLoginAccess: isLoginAccess,\n        }), {\n            maxAge: 10 * 60 * 1000,\n            httpOnly: true,\n            secure: this.config.get('allowHttps'),\n        });\n        const redirectUri = this.generateAuthUrl(strategy, {\n            redirectUri: this.redirectUri(ctx, strategy),\n            scope: scope,\n            state: state,\n            accessType: refreshToken ? 'offline' : 'online',\n        });\n\n        return await ctx.redirect(redirectUri);\n    }\n\n    /**\n     * @param {Koa.Context} ctx\n     * @param {string} strategy\n     * @param {boolean} isConnected\n     * @returns {*}\n     */\n    async accessResponse(ctx, strategy: string, isConnected: ?boolean) {\n        if (ctx.query.error) {\n            const error = new Error(ctx.query.error);\n            error.status = 403;\n            error.expose = true;\n            throw error;\n        }\n\n        const code = ctx.query.code;\n        const state = ctx.query.state;\n        const cookieName = `auth_${strategy}_${state}`;\n        let cookie = ctx.cookies.get(cookieName);\n        ctx.cookies.set(cookieName, '', { expires: new Date(1) });\n        if (!cookie) {\n            throw new Error('No cookie for this state');\n        }\n\n        cookie = JSON.parse(cookie);\n        if (!cookie || !cookie.scope) {\n            throw new Error('Unexpected cookie value');\n        }\n\n        if (!cookie.isLoginAccess) {\n            if (!isConnected) {\n                throw new Error('You are not connected');\n            }\n        }\n\n        const tokens = await this.getTokens(strategy, {\n            code: code,\n            redirectUri: this.redirectUri(ctx, strategy),\n        });\n\n        if (cookie.isLoginAccess) {\n            const user = await this.userAccountsService.findOrCreateFromGoogle(\n                strategy,\n                tokens,\n                cookie.scope,\n                cookie.scopeKey\n            );\n            return user;\n        }\n\n        ctx.cookies.set(cookieName, '', { expires: new Date(1) });\n        const connectedUser = ctx.state.connected;\n        await this.userAccountsService.update(connectedUser, strategy, tokens, cookie.scope, cookie.scopeKey);\n        return connectedUser;\n    }\n\n    refreshAccountTokens(user, account) {\n        if (account.tokenExpireDate && account.tokenExpireDate.getTime() > Date.now()) {\n            return Promise.resolve(false);\n        }\n        return this.refreshToken(account.provider, {\n            accessToken: account.accessToken,\n            refreshToken: account.refreshToken,\n        }).then((tokens) => {\n            if (!tokens) {\n                // serviceGoogle.updateFields({ accessToken:null, refreshToken:null, status: M.Service.OUTDATED });\n                return false;\n            }\n            account.accessToken = tokens.accessToken;\n            account.tokenExpireDate = tokens.expireDate;\n            return this.userAccountsService.updateAccount(user, account).then(() => true);\n        });\n    }\n}\n"]}