{"version":3,"sources":["../src/compose.js"],"names":[],"mappings":";;;;;kBAGwB;;;;EAFxB,SAAS,IAAT,GAAgB,EAAhB;;;;;EAEe,SAAS,OAAT,CAAiB,UAAjB,EAA6B;AACxC;;;aAAO,UAAU,IAAV,EAAgB;AACnB,mBAAO,QAAQ,IAAR,CADY;AAEnB,gBAAI,IAAI,WAAW,MAAX,CAFW;AAGnB,mBAAO,GAAP,EAAY;AACR,uBAAO,KAAK,WAAW,CAAX,CAAL,EAAoB,IAApB,EAA0B,IAA1B,CAAP,CADQ;aAAZ;;AAIA,mBAAO,IAAP,CAPmB;SAAhB;MADiC;CAA7B;;;;;;;;;;;;AAqBf,SAAS,IAAT,CAAc,EAAd,EAAkB,GAAlB,EAAuB,IAAvB,EAA6B;AACzB,QAAI,OAAO,EAAP,KAAc,UAAd,EAA0B;AAC1B,cAAM,IAAI,SAAJ,CAAc,iBAAd,CAAN,CAD0B;KAA9B;;AAIA,QAAI;AACA,eAAO,QAAQ,OAAR,CAAgB,GAAG,IAAH,CAAQ,GAAR,EAAa,GAAb,EAAkB,IAAlB,CAAhB,CAAP,CADA;KAAJ,CAEE,OAAO,CAAP,EAAU;AACR,eAAO,QAAQ,MAAR,CAAe,CAAf,CAAP,CADQ;KAAV;CAPN","file":"compose.js","sourcesContent":["// create lib\nfunction noop() {}\n\nexport default function compose(middleware) {\n    return function (next) {\n        next = next || noop;\n        let i = middleware.length;\n        while (i--) {\n            next = wrap(middleware[i], this, next);\n        }\n\n        return next;\n    };\n}\n\n/**\n* Wrap a function, then lazily call it,\n* always returning both a promise and a generator.\n*\n* @param {Function} fn\n* @param {Object} ctx\n* @param {Wrap} next\n*/\n\nfunction wrap(fn, ctx, next) {\n    if (typeof fn !== 'function') {\n        throw new TypeError('Not a function!');\n    }\n\n    try {\n        return Promise.resolve(fn.call(ctx, ctx, next));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}\n"]}