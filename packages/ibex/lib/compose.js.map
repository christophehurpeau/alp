{"version":3,"sources":["../src/compose.js"],"names":[],"mappings":";;;;;kBAGwB,OAAO;;AAF/B,SAAS,IAAI,GAAG,EAAE;;AAEH,SAAS,OAAO,CAAC,UAAU,EAAE;AACxC,WAAO,UAAU,IAAI,EAAE;AACnB,YAAI,GAAG,IAAI,IAAI,IAAI,CAAC;AACpB,YAAI,CAAC,GAAG,UAAU,CAAC,MAAM,CAAC;AAC1B,eAAO,CAAC,EAAE,EAAE;AACR,gBAAI,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;SAC1C;;AAED,eAAO,IAAI,CAAC;KACf,CAAC;CACL;;;;;;;;;;;AAAA,AAWD,SAAS,IAAI,CAAC,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE;AACzB,QAAI,OAAO,EAAE,KAAK,UAAU,EAAE;AAC1B,cAAM,IAAI,SAAS,CAAC,iBAAiB,CAAC,CAAC;KAC1C;;AAED,QAAI;AACA,eAAO,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;KACnD,CAAC,OAAO,CAAC,EAAE;AACR,eAAO,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;KAC5B;CACJ","file":"compose.js","sourcesContent":["// create lib\nfunction noop() {}\n\nexport default function compose(middleware) {\n    return function (next) {\n        next = next || noop;\n        let i = middleware.length;\n        while (i--) {\n            next = wrap(middleware[i], this, next);\n        }\n\n        return next;\n    };\n}\n\n/**\n* Wrap a function, then lazily call it,\n* always returning both a promise and a generator.\n*\n* @param {Function} fn\n* @param {Object} ctx\n* @param {Wrap} next\n*/\n\nfunction wrap(fn, ctx, next) {\n    if (typeof fn !== 'function') {\n        throw new TypeError('Not a function!');\n    }\n\n    try {\n        return Promise.resolve(fn.call(ctx, ctx, next));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}\n"]}