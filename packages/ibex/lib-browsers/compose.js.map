{"version":3,"sources":["../src/compose.js"],"names":[],"mappings":";;;;;kBAGwB,O;AAHxB;AACA,SAAS,IAAT,GAAgB,CAAE;;AAEH,SAAS,OAAT,CAAiB,UAAjB,EAA6B;AACxC,WAAO,UAAU,IAAV,EAAgB;AACnB,eAAO,QAAQ,IAAf;AACA,YAAI,IAAI,WAAW,MAAnB;AACA,eAAO,GAAP,EAAY;AACR,mBAAO,KAAK,WAAW,CAAX,CAAL,EAAoB,IAApB,EAA0B,IAA1B,CAAP;AACH;;AAED,eAAO,IAAP;AACH,KARD;AASH;;AAED;;;;;;;;;AASA,SAAS,IAAT,CAAc,EAAd,EAAkB,GAAlB,EAAuB,IAAvB,EAA6B;AACzB,QAAI,OAAO,EAAP,KAAc,UAAlB,EAA8B;AAC1B,cAAM,IAAI,SAAJ,CAAc,iBAAd,CAAN;AACH;;AAED,QAAI;AACA,eAAO,QAAQ,OAAR,CAAgB,GAAG,IAAH,CAAQ,GAAR,EAAa,GAAb,EAAkB,IAAlB,CAAhB,CAAP;AACH,KAFD,CAEE,OAAO,CAAP,EAAU;AACR,eAAO,QAAQ,MAAR,CAAe,CAAf,CAAP;AACH;AACJ","file":"compose.js","sourcesContent":["// create lib\nfunction noop() {}\n\nexport default function compose(middleware) {\n    return function (next) {\n        next = next || noop;\n        let i = middleware.length;\n        while (i--) {\n            next = wrap(middleware[i], this, next);\n        }\n\n        return next;\n    };\n}\n\n/**\n* Wrap a function, then lazily call it,\n* always returning both a promise and a generator.\n*\n* @param {Function} fn\n* @param {Object} ctx\n* @param {Wrap} next\n*/\n\nfunction wrap(fn, ctx, next) {\n    if (typeof fn !== 'function') {\n        throw new TypeError('Not a function!');\n    }\n\n    try {\n        return Promise.resolve(fn.call(ctx, ctx, next));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}\n"]}