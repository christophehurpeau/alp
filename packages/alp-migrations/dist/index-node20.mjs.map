{"version":3,"file":"index-node20.mjs","sources":["../src/readRecursiveDirectory.ts","../src/Manager.ts","../src/index.ts"],"sourcesContent":["import type { Stats } from \"node:fs\";\nimport { stat as fsStat, readdir } from \"node:fs/promises\";\n\nexport interface CallbackParam {\n  filename: string;\n  basedir: string;\n  path: string;\n  stat: Stats;\n}\n\nexport default async function readRecursiveDirectory(\n  directory: string,\n  callback: (param: CallbackParam) => Promise<void> | void,\n): Promise<void> {\n  const files = await readdir(directory);\n\n  await Promise.all(\n    files.map(async (file): Promise<void> => {\n      const path = `${directory}/${file}`;\n      const stat = await fsStat(path);\n\n      if (stat.isDirectory()) {\n        await readRecursiveDirectory(path, callback);\n        return;\n      }\n      await callback({\n        filename: file,\n        basedir: directory,\n        path,\n        stat,\n      });\n    }),\n  );\n}\n","import type { MongoBaseModel, MongoInsertType, MongoStore } from \"liwi-mongo\";\n\nexport interface Migration extends MongoBaseModel {\n  version: string;\n  fileName: string;\n}\n\nexport default class MigrationsManager {\n  store: MongoStore<Migration>;\n\n  constructor(store: MongoStore<Migration>) {\n    this.store = store;\n  }\n\n  findLastVersion(): Promise<string | undefined> {\n    return this.store.findOne({}, { created: -1 }).then((row) => row?.version);\n  }\n\n  addMigrationDone(migration: MongoInsertType<Migration>): Promise<Migration> {\n    return this.store.insertOne(migration);\n  }\n}\n","/* eslint-disable unicorn/no-process-exit */\nimport type AlpNodeApp from \"alp-node\";\nimport { Logger } from \"nightingale-logger\";\nimport semver from \"semver\";\nimport type MigrationsManager from \"./Manager\";\nimport type { CallbackParam } from \"./readRecursiveDirectory\";\nimport readRecursiveDirectory from \"./readRecursiveDirectory\";\n\nconst logger = new Logger(\"alp:migrations\");\n\nexport { default as MigrationsManager } from \"./Manager\";\n\nexport interface Options {\n  app: AlpNodeApp;\n  migrationsManager: MigrationsManager;\n  config?: AlpNodeApp[\"config\"];\n  dirname?: string;\n}\n\nexport default async function migrate({\n  app,\n  migrationsManager,\n  config = app.config,\n  dirname = `${app.dirname}/migrations`,\n}: Options): Promise<void> {\n  const unhandledRejectionHandler = (reason: unknown): void => {\n    logger.error(\"unhandledRejection\", { err: reason });\n\n    process.exit(1);\n  };\n  process.on(\"unhandledRejection\", unhandledRejectionHandler);\n\n  const packageVersion = config.packageConfig.version as string;\n  const currentVersion = await migrationsManager.findLastVersion();\n\n  let migrations: { version: string; fileName: string }[] = [];\n\n  logger.info(\"migrate\", { packageVersion, currentVersion });\n\n  await readRecursiveDirectory(dirname, (res: CallbackParam) => {\n    const fileName = res.path.slice(dirname.length + 1);\n\n    if (!fileName.endsWith(\".js\")) {\n      return;\n    }\n\n    const versionExecResult = /([\\d.]+)(?:_.*|\\.js)$/.exec(fileName);\n\n    if (!versionExecResult?.[1]) {\n      return;\n    }\n\n    const version: string = versionExecResult[1];\n\n    if (currentVersion && semver.lte(version, currentVersion)) return;\n\n    migrations.push({ version, fileName });\n  });\n\n  migrations = migrations.sort((a, b) =>\n    semver.gt(a.version, b.version) ? 1 : -1,\n  );\n\n  try {\n    for (const migration of migrations) {\n      logger.info(`Migration to ${migration.fileName}`);\n      try {\n        const migrateFn: unknown = await import(\n          `${dirname}/${migration.fileName}`\n        );\n        await (migrateFn as () => Promise<void>)();\n      } catch (error) {\n        logger.error(`Migration to ${migration.version} Failed !`);\n        throw error;\n      }\n\n      logger.success(`Migration to ${migration.fileName} done !`);\n\n      // only add to db if migration version <= package version\n      if (semver.lte(migration.version, packageVersion)) {\n        await migrationsManager.addMigrationDone(migration);\n      }\n    }\n  } catch (error: any) {\n    logger.error(error as Error);\n    process.exit(1);\n  }\n\n  process.removeListener(\"unhandledRejection\", unhandledRejectionHandler);\n}\n"],"names":["readRecursiveDirectory","directory","callback","files","readdir","Promise","all","map","file","path","stat","fsStat","isDirectory","filename","basedir","MigrationsManager","constructor","store","findLastVersion","findOne","created","then","row","version","addMigrationDone","migration","insertOne","logger","Logger","migrate","app","migrationsManager","config","dirname","unhandledRejectionHandler","reason","error","err","process","exit","on","packageVersion","packageConfig","currentVersion","migrations","info","res","fileName","slice","length","endsWith","versionExecResult","exec","semver","lte","push","sort","a","b","gt","migrateFn","success","removeListener"],"mappings":"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"}